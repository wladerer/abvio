{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Abvio","text":"<p>One of the things that I have always bemoaned is how bad input files are. But oh my god. I understand now that an input file with consistent and succinct syntax is so incredibly difficult to make. Rigidity and asking the user to learn how to write input files is far better than trying to anticipate all of the possibilities. If you are trying to add flexibility in an input file, it leads to unintended consequences that the user might be unaware of. Additionally, if there is more than one way to do something, then it becomes far too confusing (cough cough QuantumEspresso) </p> <p>Conversely, rigidity does not allow for users to solve new problems that the developer hasn't considered before. If an input file does not allow abstraction or flexibility, then the user is confined to the conventions that you have thrust upon them. </p> <p>Furthermore, rigid input files do not entirely solve the problem of unintended consequences. Specifically, if the program does not warn the user of unrecognized input tags, then that value is set to the default setting. I know this can be boiled down to \"skill issue\" or \"bad software design\", but there can be nefarious consequences to even long time users! </p> <p>One example I can provide is that I had been blissfully unaware of a misspelling in my INCAR file. No warning or strange behavior had come of it. A sample of my input file is the following</p> <pre><code>EDIFF = 1e-06\nEDIFFG = -0.01\nNSW = 100\nNELM = 30\nIBRION = 2\nENCUT = 600\nIDVW = 11\nLWAVE = False\nLAECHG = True\n</code></pre> <p>This file will run a perfectly fine VASP calculation with no warnings. But when life gives you melons, you might have misspelled an INCAR tag. In particular, <code>IVDW</code> is a totally, absolutely fine abbreviation. Especially as a chemist I should be trained to recognize the short hand for van der Waals. But as an American, I must pin this on the developers as a silly thing to let slide.</p> <p>In my angst (and also Covid quaruntine), I decided to take up a challenge of writing a better input file for VASP calculations. In doing so, I have created the aptly named <code>abvio</code> (a better VASP input and output) python package. Developing this project was metaphorical and actual fever dream. You might notice this in some of the hastily written doc strings and naming conventions. Thankfully, the abvio package comes with comprehensive tests so hopefully that will allow me (or someone who is foolish enough to make a PR) to polish the codebase up in a reasonable time frame. </p> <p>What I attempted to do is take a well understood data structure that provides both flexibility and convention and adorn in with ab initio jargon. This provides a few enormous benefits. One such benefit is that the foundation of your input file is well documented, tested, and understood by a wide audience. </p> <p>Specifically, I have chosen to use a yaml file. Although, it is less familiar to people than perhaps json or csv, yaml is quick to learn and easy to read (mostly).</p> <p>The following is an example of what a spin-orbit coupled band structure calculation of fluorite looks like</p> <pre><code>structure:\n    mode: manual\n    species: \n        Ca: 4\n        F: 8\n    lattice:\n        a: 5.516052\n        b: 5.516052\n        c: 5.516052\n        alpha: 90.0\n        beta: 90.0\n        gamma: 90.0\n    coords: [\n        [0.0, 0.0, 0.0],\n        [0.0, 2.758, 2.758],\n        [2.758, 0.0, 2.758],\n        [2.758, 2.758, 0.0],\n        [1.379, 4.137, 1.379],\n        [1.379, 4.137, 4.137],\n        [1.379, 1.379, 4.137],\n        [1.379, 1.379, 1.379],\n        [4.137, 4.137, 4.137],\n        [4.137, 4.137, 1.379],\n        [4.137, 1.379, 1.379],\n        [4.137, 1.379, 4.137],\n        ]\nincar:\n    ediff: 1e-6\n    encut: 500\n    nelm: 35\n    ibrion: 2\n    lsorbit: true\n    lorbit: 11\n    magmom:\n        Ca: [0, 0, 1.0]\n        F: [0, 0, 0]\nkpoints:\n    mode: autoline\n    spacing: 30\n</code></pre> <p>Currently, I am still unsure if this is aesthetically or functionally better than any other input file. Maybe let me know what you think. </p> <p>What is nice about this format is that everything is in one place. You can understand the relation of your structure and what the program will do with it. For example, MAGMOM is no longer a mess of arithemtic. You can specify by species and provide an array of the spin-axes. Also, abvio can intelligently determine the band structure path of the input structure. All you have to do is specify the number of kpoints per path. </p> <p>If these options aren't what you want, this input file supports all modes of kpoints generation. </p> <p>What makes this easier to understand is that the methods are flexible, but the user must be aware of state. In this case, the <code>mode</code> parameter handles instances where state can change. This ensures that both the program and the user understand which method will be used to construct the structure and reciprocal space sampling scheme.</p> <p>An even more terse inputs file can be used to demonstrate the convenience of this input file structure.</p> <p>The following file does exactly the same as the previous, but in this case all we need to do is pass the canonical name of a specific structure type and the species that will fill the distinct sites. We then only need to pass modifications to the lattice parameter.</p> <pre><code>structure:\n    mode: prototype\n    prototype: fluorite\n    species: [Ca, F]\n    lattice:\n        a: 5.516052\nincar:\n    ediff: 1e-6\n    encut: 500\n    nelm: 35\n    ibrion: 2\n    lsorbit: true\n    lorbit: 11\n    magmom:\n        Ca: [0, 0, 1.0]\n        F: [0, 0, 0]\nkpoints:\n    mode: autoline\n    spacing: 30\n</code></pre> <p>Finally, if we are feeling even lazier, we can pull structures from materials project directly (so long as you have an API key).</p> <pre><code>structure:\n    mode: external\n    code: mp-2741\nincar:\n    ediff: 1e-6\n    encut: 500\n    nelm: 35\n    ibrion: 2\n    lsorbit: true\n    lorbit: 11\n    magmom:\n        Ca: [0, 0, 1.0]\n        F: [0, 0, 0]\nkpoints:\n    mode: autoline\n    spacing: 30\n</code></pre> <p>Each of these files will create the same set of VASP input files (you can check the tests to see if I am telling the truth!). </p> <p>Input files, much like young grad students, need validation. In fact, I don't quite understand why some ab initio suites don't do some form of sanity check and just lets the calculations crash. Once again, yes due diligence of the user is paramount. But hey, sometimes people make mistakes. </p> <p>So, I have attempted to bake sanity checks, input validation, and some wisdom into the processing of the input file. If you end up using this code, many warnings (and possibly errors) will be brought to the users attention even before the calculation has started. This might prevent a millisecond long disaster on week-long slurm queues. </p> <p>If you want to try it out, feel free to take any of the above files and test them using the command line interface by running</p> <pre><code>abvio input.yaml -o /tmp\n</code></pre> <p>Which will write INCAR, KPOINTS, and POSCAR to the root tmp directory (just make sure you change the file name in the command to match your file name). </p> <p>You can also preview what the output should look like using </p> <pre><code>abvio input.yaml --preview\n</code></pre> <p>Which will give an output like this</p> <p></p>"},{"location":"format/","title":"abvio input files and yaml","text":"<p>This section will give an overview of both the yaml format and the abvio input file format</p>"},{"location":"format/#yaml","title":"yaml","text":"<p>Yaml is a file format designed to be human readable but easily parsed by software. This is achieved by strcturing everything as <code>key:value</code> pairs. In practice, this just means that everything in the file has a label and we can access those things by referencing the labels by calling its name. For example, if I wanted to refer to look up the \"mythical creatures\" section of the following file</p> <pre><code>mythical creatures:\n    - sasquatch:\n        age: 1032\n        diet: poutine\n        power: is blurry\n        location: Wisconsin, USA\n    - lochness monster:\n        age: false\n        diet: horses\n        power: shapeshifts into driftwood\n        location: Lake Wakatipu, NZ\nsuspicious:\n    sto3g: true\n    ano-rcc-vtz: true\n    clebcsh-gordan: false\npauli-matrix:\n    - [ 1, 0]\n    - [ 0,-1]\npauli-matrices:\n    - [[0, 1],\n       [1, 0]]\n    - [[0, -i],\n       [i,  0]]\n</code></pre> <p>I would get back a list of two dictionaries: <code>sasquatch</code> and <code>lochness monster</code> that contains more key value pairs about each creature.</p> <p>To our benefit, and our detriment, there is some flexibility in the way we can represent the same things. You will notice that in the <code>pauli-matrix</code> entry we write out a matrix as a list of lists using a <code>-</code> next to each row of the matrix. Whereas, <code>pauli-matrices</code> is a list of lists of lists (aka a list of matrices). This will be an important distinction if you are writing coordinates, lattices, or band structure paths manually. </p>"},{"location":"format/#abvio-yaml","title":"abvio yaml","text":"<p>There are only a few \"rules\" when it comes to abvio. </p>"},{"location":"format/#structure-incar-and-kpoints-must-be-in-the-highest-scope-of-the-file","title":"structure, incar, and kpoints must be in the highest scope of the file","text":"<p>Unfortunately, the difference is hard to see, but \"scope\" or hierarchy is distinguished by indentation. The following is a valid abvio yaml file</p> <p>Good:  <pre><code> structure:\n    ...\n kpoints:\n    spacing: 800\n    mode: spacing\n incar:\n   ...\n</code></pre></p> <p>Where this one is not</p> <p>Bad:  <pre><code> structure:\n    ...\n   kpoints:\n       spacing: 800\n       mode: spacing\n incar:\n   ...\n</code></pre></p> <p>Thankfully, abvio will let you know it is missing \"kpoints\" when you try to write the VASP input files.</p>"},{"location":"format/#structure-and-kpoints-must-always-have-a-mode-tag","title":"structure and kpoints must always have a mode tag","text":"<p>abvio requires a \"mode\" tag to handle the many options of creating structures and kpoint meshes. You can find all of these features listed further down in the documentation. </p>"},{"location":"format/#ranges-requires-a-start-stop-and-value","title":"ranges requires a start, stop, and value","text":"<p>when assigning site properties like <code>MAGMOM</code> and <code>LDAUU</code>, there is a 'range' option. This is detected automatically (therefore no need to add <code>mode</code>), but will need to explicitly state the start, stop, and value of the site property in the following way</p> <pre><code>incar:\n    ispin: 2\n    magmom:\n        - {start: 0, stop: 12, value: 3.4}\n</code></pre> <p>Where the above example would apply a magnetic moment of 3.4 to the first twelve atoms in your structure. We can also apply \"step\" to this logic as well, where the following range would apply alternating values of [Sx = 0, Sy = 0, Sz=1] and [Sx = 0, Sy = 0, Sz=-1]</p> <pre><code>incar:\n    lsorbit: true\n    magmom:\n        - {start: 0, stop: 12, step: 2, value: [0, 0, 1]}\n        - {start: 1, stop: 12, step: 2, value: [0, 0, -1]}\n</code></pre> <p>Which might come in handy if you are trying to create a spin-orbit coupled antiferromagnet. </p>"},{"location":"format/#section-specific-rules","title":"section specific rules","text":""},{"location":"format/#structure","title":"structure","text":"<p>structure tries to be as flexible as possible, including allowing the user to simply just provide a path to a file if they so choose. </p> mode Expect Inputs(s) Notes external file | string | code code must be in the format mp-... manual species, lattice, coords lattice can be an array or a dictionary prototype protoype, lattice at least one lattice constant is required"},{"location":"format/#kpoints","title":"kpoints","text":"<p>kpoints is less flexible and is honestly the least well implemented feature at the moment. <code>spacing</code> must always be specified, regardless of the mode. The user must be aware that spacing can refer to kpoint mesh density per volume, unit length, or path. This might be confusing at first. I will put this in a warning box just so it's extra clear</p> <p>Danger</p> <p><code>spacing</code> keyword can refer to kpoint mesh density per volume, unit length, or path</p> mode Spacing format Notes gamma list traditional [kx, ky, kz] or explicit monkhorst list you can misspell this one (same as gamma) line list only need to specify a point on a path once autoline integer will generate labels and paths for you surface integer must be quite high for fermi surfaces (800+)"},{"location":"jobs/","title":"Automatic Generation of PBS/Slurm scripts","text":"<p>There is an experimental feature that allows you to create PBS/SLURM scripts. It is able to take the same input arguments and produce either a PBS or Slurm script with the appropriate directives. In the future, this will be integrated into the entire checking system to ensure the user has provided the correct executable (gamma, noncollinear, standard) and potential options for automatic parallelization optimality between incar, structure, and system hardware. </p> <p>Using this functionality is quite simple, an example of a complete input file is the following</p> <pre><code>incar:\n  ediff: 1e-6\n  ediffg: -0.01\n  encut: 600\n  nsw: 25\n  ibrion: 2\n  isif: 3\n  nelm: 99 \n  magmom: \n      Ca: 0.0\n      Ti: 2.0\n      O: 0.0\n  lwave: false\nstructure:\n  mode: prototype\n  prototype: perovskite\n  species: [Ca, Ti, O]\n  lattice:\n    a: 3.889471\nkpoints:\n  mode: gamma\n  spacing: [7, 7, 7]\njob:\n  scheduler: 'slurm'\n  directives_dict:\n    nodes: 2\n    cores: 4\n    memory: '8G'\n    shebang: '#!/bin/bash'\n    script:\n      - 'echo \"Hello World\"'\n      - 'echo \"Goodbye World\"'\n</code></pre> <p>Which will create a VASP input set that contains the following files </p>"},{"location":"jobs/#incar","title":"INCAR","text":"<pre><code>EDIFF = 1e-6\nEDIFFG = -0.01\nENCUT = 600\nIBRION = 2\nISIF = 3\nLWAVE = False\nMAGMOM = 1*0.0 1*2.0 3*0.0\nNELM = 99\nNSW = 25\n</code></pre>"},{"location":"jobs/#poscar","title":"POSCAR","text":"<pre><code>Ca1 Ti1 O3\n1.0\n   3.8894709999999999    0.0000000000000000    0.0000000000000000\n   0.0000000000000000    3.8894709999999999    0.0000000000000000\n   0.0000000000000000    0.0000000000000000    3.8894709999999999\nCa Ti O\n1 1 3\ndirect\n   0.0000000000000000    0.0000000000000000    0.0000000000000000 Ca\n   0.5000000000000000    0.5000000000000000    0.5000000000000000 Ti\n   0.5000000000000000    0.0000000000000000    0.5000000000000000 O\n   0.0000000000000000    0.5000000000000000    0.5000000000000000 O\n   0.5000000000000000    0.5000000000000000    0.0000000000000000 O\n</code></pre>"},{"location":"jobs/#kpoints","title":"KPOINTS","text":"<pre><code>Automatic kpoint scheme\n0\nGamma\n7 7 7\n</code></pre>"},{"location":"jobs/#submitsh","title":"submit.sh","text":"<pre><code>#!/bin/bash\n#SBATCH -J vaspslurm\n#SBATCH -n 1\n#SBATCH --cpus-per-task=4\n#SBATCH --mem=8G\n#SBATCH -t 00:30:00\n#SBATCH --nodes=2\necho \"Hello World\"\necho \"Goodbye World\n</code></pre> <p>We can change the <code>scheduler</code> value to 'pbs' and would produce the following</p> <pre><code>#!/bin/bash\n#PBS -N vasppbs\n#PBS -l select=1:ncpus=4:mem=7630MB\n#PBS -l walltime=00:30:00\n#PBS -l nodes=2\necho \"Hello World\"\necho \"Goodbye World\"\n</code></pre> <p>I hope this provides you with some portability in generating equivalent jobs across different HPCs. </p>"},{"location":"quickstart/","title":"Installation","text":"<p>abvio is currently only available on PyPI, but you can clone the repository and install it yourself </p> <pre><code>pip install abvio\n</code></pre>"},{"location":"quickstart/#cli-usage","title":"CLI Usage","text":"<p>abvio is a CLI-first program. Therefore, the only entry-point you will need is the <code>abvio</code> command. We can run a quick example of converting your own VASP input set to an abvio.yaml file to get a feel for the format. We can do this by navigating to the directory containing your VASP input files and running the following command</p> <pre><code>abvio . --convert -o myfile.yaml\n</code></pre> <p>Which will produce a file named <code>myfile.yaml</code>. You can then verify that this worked by running</p> <pre><code>abvio myfile.yaml --preview\n</code></pre> <p>And it will give you a formatted glimpse of what it has read in. If you are satisfied with the results, run</p> <pre><code>abvio myfile.yaml -o . \n</code></pre> <p>which will write out the files INCAR, KPOINTS, and POSCAR. Be careful though, this program will overwrite exisiting files!</p>"},{"location":"quickstart/#writing-an-input-file","title":"Writing an input file","text":"<p>My recommendation to writing your first input file would be to start with the simplest thing and go from there. This is why I recommend you working with either prototype structures or pulling from the materials project structure repository. Since this tutorial should get you up and running quickly, we will be working with prototypes as they do not require you setting up a Materials Project account/API key. </p> <p>A rough outline is always recommended:</p> <ol> <li>structure is DySb (rock salt structure!)</li> <li>we want a fine sampling, so 60 kpoints per path</li> </ol> <p>We can quickly translate that into a file</p> <pre><code>structure:\n    mode: prototype\n    prototype: rocksalt\n    species: [Dy, Sb]\n    lattice:\n        a: 4.23\nincar:\n    ediff: 1e-06\n    lorbit: 11\n    encut: 600\nkpoints:\n    mode: autoline\n    spacing: 60\n</code></pre> <p>And if we run preview, we will get the following output:</p> <p></p>"}]}